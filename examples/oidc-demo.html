<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SEKAI Pass - OpenID Connect æ¼”ç¤º</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', 'Noto Sans SC', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 16px;
      padding: 40px;
      max-width: 800px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .badge {
      display: inline-block;
      background: #10b981;
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .badge.oidc {
      background: #3b82f6;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
      line-height: 1.6;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f9fafb;
      border-radius: 8px;
      border-left: 4px solid #3b82f6;
    }

    .section h2 {
      color: #333;
      font-size: 18px;
      margin-bottom: 15px;
    }

    .info-grid {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 12px;
      font-size: 14px;
    }

    .info-label {
      color: #666;
      font-weight: 600;
    }

    .info-value {
      color: #333;
      word-break: break-all;
      font-family: 'Monaco', 'Courier New', monospace;
      background: white;
      padding: 8px 12px;
      border-radius: 4px;
    }

    button {
      width: 100%;
      padding: 14px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 10px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .token-display {
      background: #1e293b;
      color: #e2e8f0;
      padding: 16px;
      border-radius: 8px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 300px;
      overflow-y: auto;
    }

    .claims-display {
      background: white;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }

    .claim-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #f3f4f6;
    }

    .claim-item:last-child {
      border-bottom: none;
    }

    .claim-key {
      font-weight: 600;
      color: #3b82f6;
      font-family: 'Monaco', 'Courier New', monospace;
    }

    .claim-value {
      color: #333;
      font-family: 'Monaco', 'Courier New', monospace;
      text-align: right;
    }

    .status {
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .status.success {
      background: #d1fae5;
      color: #065f46;
      border: 1px solid #10b981;
    }

    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #ef4444;
    }

    .status.info {
      background: #dbeafe;
      color: #1e40af;
      border: 1px solid #3b82f6;
    }

    .feature-list {
      list-style: none;
      padding: 0;
    }

    .feature-list li {
      padding: 8px 0;
      padding-left: 24px;
      position: relative;
    }

    .feature-list li:before {
      content: "âœ“";
      position: absolute;
      left: 0;
      color: #10b981;
      font-weight: bold;
    }

    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 20px;
    }

    .btn-secondary {
      background: #6b7280;
    }

    .btn-secondary:hover {
      box-shadow: 0 10px 30px rgba(107, 114, 128, 0.4);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      ğŸ” SEKAI Pass
      <span class="badge oidc">OpenID Connect</span>
    </h1>
    <p class="subtitle">
      OpenID Connect (OIDC) é›†æˆæ¼”ç¤º - ä½¿ç”¨ ID Token è¿›è¡Œèº«ä»½éªŒè¯
    </p>

    <div class="section">
      <h2>ğŸ“‹ OIDC åŠŸèƒ½ç‰¹æ€§</h2>
      <ul class="feature-list">
        <li>æ ‡å‡†åŒ–çš„èº«ä»½éªŒè¯å±‚ï¼ˆåŸºäº OAuth 2.1ï¼‰</li>
        <li>ç­¾åçš„ JWT ID Tokenï¼ˆES256 ç®—æ³•ï¼‰</li>
        <li>æ”¯æŒ nonce é˜²é‡æ”¾æ”»å‡»</li>
        <li>åŸºäº scope çš„å£°æ˜æ˜ å°„</li>
        <li>å®Œå…¨å‘åå…¼å®¹ OAuth 2.1</li>
      </ul>
    </div>

    <div id="status"></div>

    <div id="loginSection">
      <div class="section">
        <h2>ğŸš€ é…ç½®ä¿¡æ¯</h2>
        <div class="info-grid">
          <div class="info-label">æˆæƒæœåŠ¡å™¨:</div>
          <div class="info-value" id="issuer">https://id.nightcord.de5.net</div>

          <div class="info-label">Client ID:</div>
          <div class="info-value" id="clientId">demo-client</div>

          <div class="info-label">Redirect URI:</div>
          <div class="info-value" id="redirectUri">-</div>

          <div class="info-label">Scope:</div>
          <div class="info-value">openid profile email</div>

          <div class="info-label">Response Type:</div>
          <div class="info-value">code</div>

          <div class="info-label">PKCE:</div>
          <div class="info-value">S256 (å¼ºåˆ¶)</div>
        </div>
      </div>

      <button onclick="startOIDCLogin()">ğŸ”‘ ä½¿ç”¨ OIDC ç™»å½•</button>
      <div class="button-group">
        <button class="btn-secondary" onclick="testDiscovery()">ğŸ“‹ æµ‹è¯• Discovery</button>
        <button class="btn-secondary" onclick="testJWKS()">ğŸ” æµ‹è¯• JWKS</button>
      </div>
    </div>

    <div id="tokenSection" style="display: none;">
      <div class="section">
        <h2>ğŸ« ID Token (JWT)</h2>
        <div class="token-display" id="idTokenDisplay"></div>
      </div>

      <div class="section">
        <h2>ğŸ“ ID Token Claims</h2>
        <div class="claims-display" id="claimsDisplay"></div>
      </div>

      <div class="section">
        <h2>ğŸ”‘ Access Token</h2>
        <div class="token-display" id="accessTokenDisplay"></div>
      </div>

      <div class="button-group">
        <button onclick="testUserInfo()">ğŸ‘¤ è·å–ç”¨æˆ·ä¿¡æ¯</button>
        <button class="btn-secondary" onclick="logout()">ğŸšª é€€å‡ºç™»å½•</button>
      </div>
    </div>
  </div>

  <script>
    const CONFIG = {
      issuer: 'https://id.nightcord.de5.net',
      clientId: 'demo-client',
      redirectUri: window.location.href.split('?')[0],
      scope: 'openid profile email',
      responseType: 'code'
    };

    // æ›´æ–°é¡µé¢æ˜¾ç¤ºçš„é…ç½®
    document.getElementById('redirectUri').textContent = CONFIG.redirectUri;

    // ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
    function generateRandomString(length) {
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }

    // Base64URL ç¼–ç 
    function base64URLEncode(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
    }

    // ç”Ÿæˆ PKCE code_verifier å’Œ code_challenge
    async function generatePKCE() {
      const verifier = generateRandomString(32);
      const encoder = new TextEncoder();
      const data = encoder.encode(verifier);
      const hash = await crypto.subtle.digest('SHA-256', data);
      const challenge = base64URLEncode(hash);
      return { verifier, challenge };
    }

    // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
    }

    // å¼€å§‹ OIDC ç™»å½•æµç¨‹
    async function startOIDCLogin() {
      try {
        showStatus('ğŸ”„ æ­£åœ¨ç”Ÿæˆ PKCE å‚æ•°...', 'info');

        const { verifier, challenge } = await generatePKCE();
        const state = generateRandomString(16);
        const nonce = generateRandomString(16);

        // ä¿å­˜åˆ° sessionStorage
        sessionStorage.setItem('pkce_verifier', verifier);
        sessionStorage.setItem('oauth_state', state);
        sessionStorage.setItem('oidc_nonce', nonce);

        // æ„å»ºæˆæƒ URL
        const params = new URLSearchParams({
          client_id: CONFIG.clientId,
          redirect_uri: CONFIG.redirectUri,
          response_type: CONFIG.responseType,
          scope: CONFIG.scope,
          state: state,
          nonce: nonce,
          code_challenge: challenge,
          code_challenge_method: 'S256'
        });

        const authUrl = `${CONFIG.issuer}/oauth/authorize?${params.toString()}`;

        showStatus('âœ… æ­£åœ¨è·³è½¬åˆ°æˆæƒé¡µé¢...', 'success');

        // è·³è½¬åˆ°æˆæƒé¡µé¢
        setTimeout(() => {
          window.location.href = authUrl;
        }, 500);
      } catch (error) {
        showStatus(`âŒ é”™è¯¯: ${error.message}`, 'error');
      }
    }

    // å¤„ç†å›è°ƒ
    async function handleCallback() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showStatus(`âŒ æˆæƒå¤±è´¥: ${error}`, 'error');
        return;
      }

      if (!code) {
        return; // ä¸æ˜¯å›è°ƒé¡µé¢
      }

      showStatus('ğŸ”„ æ­£åœ¨äº¤æ¢æˆæƒç ...', 'info');

      // éªŒè¯ state
      const savedState = sessionStorage.getItem('oauth_state');
      if (state !== savedState) {
        showStatus('âŒ State éªŒè¯å¤±è´¥ï¼å¯èƒ½å­˜åœ¨ CSRF æ”»å‡»', 'error');
        return;
      }

      // è·å– code_verifier
      const verifier = sessionStorage.getItem('pkce_verifier');
      if (!verifier) {
        showStatus('âŒ æœªæ‰¾åˆ° PKCE verifier', 'error');
        return;
      }

      try {
        // äº¤æ¢æˆæƒç è·å– token
        const tokenResponse = await fetch(`${CONFIG.issuer}/oauth/token`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code: code,
            client_id: CONFIG.clientId,
            code_verifier: verifier
          })
        });

        if (!tokenResponse.ok) {
          const errorData = await tokenResponse.json();
          throw new Error(errorData.error_description || errorData.error);
        }

        const tokens = await tokenResponse.json();

        // ä¿å­˜ tokens
        sessionStorage.setItem('access_token', tokens.access_token);
        sessionStorage.setItem('refresh_token', tokens.refresh_token);
        if (tokens.id_token) {
          sessionStorage.setItem('id_token', tokens.id_token);
        }

        // æ¸…ç† URL
        window.history.replaceState({}, document.title, CONFIG.redirectUri);

        // æ˜¾ç¤º token ä¿¡æ¯
        displayTokens(tokens);

        showStatus('âœ… ç™»å½•æˆåŠŸï¼å·²è·å– ID Token', 'success');
      } catch (error) {
        showStatus(`âŒ Token äº¤æ¢å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // è§£ç  JWT
    function decodeJWT(token) {
      const parts = token.split('.');
      if (parts.length !== 3) {
        throw new Error('Invalid JWT format');
      }

      const payload = parts[1];
      const decoded = atob(payload.replace(/-/g, '+').replace(/_/g, '/'));
      return JSON.parse(decoded);
    }

    // æ˜¾ç¤º tokens
    function displayTokens(tokens) {
      document.getElementById('loginSection').style.display = 'none';
      document.getElementById('tokenSection').style.display = 'block';

      // æ˜¾ç¤º ID Token
      if (tokens.id_token) {
        document.getElementById('idTokenDisplay').textContent = tokens.id_token;

        // è§£ç å¹¶æ˜¾ç¤º claims
        try {
          const claims = decodeJWT(tokens.id_token);
          const claimsHtml = Object.entries(claims).map(([key, value]) => {
            let displayValue = value;
            if (typeof value === 'number' && (key === 'exp' || key === 'iat' || key === 'auth_time')) {
              displayValue = `${value} (${new Date(value * 1000).toLocaleString('zh-CN')})`;
            } else if (typeof value === 'object') {
              displayValue = JSON.stringify(value);
            }
            return `
              <div class="claim-item">
                <span class="claim-key">${key}</span>
                <span class="claim-value">${displayValue}</span>
              </div>
            `;
          }).join('');
          document.getElementById('claimsDisplay').innerHTML = claimsHtml;
        } catch (error) {
          document.getElementById('claimsDisplay').textContent = 'Failed to decode claims';
        }
      }

      // æ˜¾ç¤º Access Token
      document.getElementById('accessTokenDisplay').textContent = tokens.access_token;
    }

    // æµ‹è¯• UserInfo ç«¯ç‚¹
    async function testUserInfo() {
      const accessToken = sessionStorage.getItem('access_token');
      if (!accessToken) {
        showStatus('âŒ æœªæ‰¾åˆ° access token', 'error');
        return;
      }

      try {
        showStatus('ğŸ”„ æ­£åœ¨è·å–ç”¨æˆ·ä¿¡æ¯...', 'info');

        const response = await fetch(`${CONFIG.issuer}/oauth/userinfo`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });

        if (!response.ok) {
          throw new Error('Failed to fetch user info');
        }

        const userInfo = await response.json();
        showStatus(`âœ… ç”¨æˆ·ä¿¡æ¯: ${JSON.stringify(userInfo, null, 2)}`, 'success');
      } catch (error) {
        showStatus(`âŒ è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // æµ‹è¯• Discovery ç«¯ç‚¹
    async function testDiscovery() {
      try {
        showStatus('ğŸ”„ æ­£åœ¨è·å– OIDC Discovery å…ƒæ•°æ®...', 'info');

        const response = await fetch(`${CONFIG.issuer}/.well-known/openid-configuration`);
        const metadata = await response.json();

        showStatus(`âœ… Discovery æˆåŠŸï¼æ”¯æŒçš„ç®—æ³•: ${metadata.id_token_signing_alg_values_supported.join(', ')}`, 'success');
        console.log('OIDC Metadata:', metadata);
      } catch (error) {
        showStatus(`âŒ Discovery å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // æµ‹è¯• JWKS ç«¯ç‚¹
    async function testJWKS() {
      try {
        showStatus('ğŸ”„ æ­£åœ¨è·å– JWKS...', 'info');

        const response = await fetch(`${CONFIG.issuer}/.well-known/jwks.json`);
        const jwks = await response.json();

        const keyCount = jwks.keys.length;
        if (keyCount === 0) {
          showStatus('âš ï¸ JWKS ä¸ºç©ºï¼ˆå¯†é’¥å°†åœ¨é¦–æ¬¡ OIDC è¯·æ±‚æ—¶ç”Ÿæˆï¼‰', 'info');
        } else {
          showStatus(`âœ… JWKS æˆåŠŸï¼æ‰¾åˆ° ${keyCount} ä¸ªå¯†é’¥`, 'success');
        }
        console.log('JWKS:', jwks);
      } catch (error) {
        showStatus(`âŒ JWKS å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // é€€å‡ºç™»å½•
    function logout() {
      sessionStorage.clear();
      window.location.reload();
    }

    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦æœ‰å›è°ƒå‚æ•°
    window.addEventListener('DOMContentLoaded', () => {
      handleCallback();

      // å¦‚æœå·²ç»æœ‰ tokenï¼Œæ˜¾ç¤º token ä¿¡æ¯
      const idToken = sessionStorage.getItem('id_token');
      const accessToken = sessionStorage.getItem('access_token');
      if (idToken && accessToken) {
        displayTokens({
          id_token: idToken,
          access_token: accessToken
        });
      }
    });
  </script>
</body>
</html>
